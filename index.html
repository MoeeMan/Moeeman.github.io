<!DOCTYPE HTML>
<!--
	Story by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>index.html</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper" class="divided">
					<section class="banner style1 orient-left content-align-left image-position-right fullscreen onload-image-fade-in onload-content-fade-right">
						<div class="content">
							<h1>STM32 RC Car</h1>
							<p class="major">A project by Muhmin Abdeljaber.</p>
							<ul class="actions stacked">
								<li><a href="#first" class="button big wide smooth-scroll-middle">Get Started</a></li>
							</ul>
						</div>
						<div class="image">
							<img src="images/gallery/design/cover.png" alt="" />
						</div>
					</section>
					
				<!-- Overview -->
					<section class="wrapper style1 align-center" id="first">
						<div class="inner">
							<h2>Overview</h2>
							<p>A couple of years back, I dived into a fun RC car project with a basic Arduino kit, one of those entry-level setups 
								like the one below.</p>
								<div class="image">
									<img src="images/gallery/design/old_rc_car.png" alt="" />
								</div>
							<p>Looking back, I realized I had little experience with key aspects like interrupt events, power supplies, motor drivers, 
								and wireless communication. The initial hurdle came with the power supply and motor driver. Attempting to get the RC car 
								to move in various directions, I used 4 AA batteries (6V) and an L298N motor driver for four motors. However, due to a 
								voltage drop in the L298N, especially at higher loads, running four motors on two channels barely got the car moving. 
								Faced with this issue, I changed my initial approach by leaving Bluetooth communication aside and transforming the project 
								into an obstacle avoidance robot using an ultrasonic sensor. Despite not implementing interrupts and relying solely on 
								polling in the code, it worked fine since there was only one sensor to manage. And there, my project came to a halt.</p>
							<p>Fast forward to today, I decided to revisit the project, aiming to overcome past issues and create a fully functional 
								RC car with a transmitter and receiver. Opting for an STM32 board instead of Arduino, given my experience with the Cortex 
								M4 processor, I recognized that with multiple concurrent tasks, polling wouldn't cut it. Hence, I switched to using 
								RTOS to handle various tasks. Just as I was about to order another RC car kit to kickstart the new project, I stumbled upon 
								a game-changing idea. This new approach involved modifying a commercially bought RC car to be controlled with a custom-built 
								transmitter. This approach allowed me to use both the internal and external components of the RC car for appearance 
								and functionality alike. Credit for these clever ideas goes to Dejan at HowToMechatronics, who shared insights into both the
								<a href="https://howtomechatronics.com/projects/diy-arduino-rc-receiver/">RC car modification</a> and
								<a href="https://howtomechatronics.com/projects/diy-arduino-rc-transmitter/">custom transmitter</a>.</p>						
						</div>
					</section>
					
				<!-- Six -->
					<section class="wrapper style2 align-center">
						<div class="inner">
							<h2>Components List</h2>
							<h3>Receiver</h3>
							<div class="items style1 medium onscroll-fade-in">
								<section>
									<div class="image">
										<img src="images/gallery/receiver_components/rc_car.png" alt="" />
									</div>
									<h3>RC Car</h3>
									<p>Bought from Amazon. Equipped with a 280 brushed DC motor, DC motor driver, and a 7.4V 1200mAh battery. 
										If another RC car is used, make sure the motor is brushed (not brushless with an ESC) and is compatible with 7.4V.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/receiver_components/l432kc.png" alt="" />
									</div>
									<h3>NUCLEO-L432KC</h3>
									<p>The microcontroller used with STM32CubeIDE.</p>
									<p>Features: Arm 32-bit Cortex-M4 CPU, 32 kHz crystal oscillator for RTC, 256KB flash, 
										64KB of SRAM, 14x communication interfaces, and a 14-channel DMA controller.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/receiver_components/motor_driver.png" alt="" />
									</div>
									<h3>DROK L298 Dual H Bridge DC Motor Driver</h3>
									<p>Voltage range is DC 6.5V-27V, 7A rated output current on each port, 160W total output power, 
										PWM frequency range of 0-10kHz, and under voltage protection.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/receiver_components/nrf24l01.png" alt="" />
									</div>
									<h3>NRF24L01+</h3>
									<p>Single chip 2.4GHz transceiver.</p> 
									<p>Data transfer rate is configurable to 250kbps, 1Mbps, or 2Mbps, operating voltage range 1.9V-3.9V, 
										output power is configurable to 0 dBm, -6 dBm, -12 dBm, or -18 dBm, 
										communicates over a 4-pin SPI with a maximum data rate of 10Mbps.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/receiver_components/capacitor.png" alt="" />
									</div>
									<h3>10uF Capacitor</h3>
									<p>Soldered between the power lines of the NRF24L01+ module to improve reliability.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/receiver_components/ultrasonic.png" alt="" />
									</div>
									<h3>HC-SR04</h3>
									<p>Ultrasonic distance sensor. Operating range of 2cm-400cm with an accuracry of 0.3cm. 5V operating voltage.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/receiver_components/battery.png" alt="" />
									</div>
									<h3>URGENEX 7.4V 2000mAh Li-ion Battery</h3>
									<p>Used to power the RC car instead of the stock battery it came with. The stock battery is used for the transmitter.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/receiver_components/pcb.png" alt="" />
									</div>
									<h3>Custom PCB</h3>
									<p>Designed in EasyEDA.</p>
								</section>
							</div>
							
							<h3>Transmitter</h3>
							<div class="items style1 medium onscroll-fade-in">
								<section>
									<div class="image">
										<img src="images/gallery/transmitter_components/l432kc.png" alt="" />
									</div>
									<h3>NUCLEO-L432KC</h3>
									<p>The microcontroller used with STM32CubeIDE.</p>
									<p>Features: Arm 32-bit Cortex-M4 CPU, 32 kHz crystal oscillator for RTC, 256KB flash, 
										64KB of SRAM,14x communication interfaces, and a 14-channel DMA controller.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter_components/joystick.png" alt="" />
									</div>
									<h3>2x Joystick</h3>
									<p>Left joystick is used for the Y-axis (throttle for back motor) and the right joystick is used for 
										the X-axis (turning for front motor )</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter_components/nrf24l01+pa+lna.png" alt="" />
									</div>
									<h3>NRF24L01+PA+LNA</h3>
									<p>Same as the normal module but includes a range extender chip that combines PA, LNA, and transmit-receive switching 
										circuitry. This enables the module to extend its transmission range up to 1000 meters.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter_components/capacitor.png" alt="" />
									</div>
									<h3>10uF Capacitor</h3>
									<p>Soldered between the power lines of the NRF24L01+PA+LNA module to improve reliability.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter_components/potentiometer.png" alt="" />
									</div>
									<h3>Potentiometer</h3>
									<p>Used for throttle control.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter_components/toggle_switch.png" alt="" />
									</div>
									<h3>SPDT Toggle Switch</h3>
									<p>Used to toggle the obstacle avoidance (HC-SR04) on/off.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter_components/slide_switch.png" alt="" />
									</div>
									<h3>SPDT Slide Switch</h3>
									<p>On/off switch for the RC car power.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter_components/battery.png" alt="" />
									</div>
									<h3>7.4V 1200mAh Li-ion Battery</h3>
									<p>Stock battery that came with the RC car. Used to power the transmitter instead.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter_components/pcb.png" alt="" />
									</div>
									<h3>Custom PCB</h3>
									<p>Designed in EasyEDA.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter_components/acrylic.png" alt="" />
									</div>
									<h3>1/8in Clear Acrylic Sheet</h3>
									<p>Cut in the shape of the PCB. Holes are also cut for the joysticks, potentiometer, and toggle switch to pass through.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter_components/spacers.png" alt="" />
									</div>
									<h3>M3 Hex Spacers</h3>
									<p>Used to secure the custom cut acrylic to the PCB.</p>
								</section>
							</div>
						</div>
					</section>		

				<!-- Two -->
					<section class="spotlight style1 orient-right content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Transmitter Circuit Diagram</h2>
							<p>At the heart of this project is the NUCLEO-L432KC microcontroller, chosen for its small size, built-in ST-LINK for easy 
							debugging, and compatibility with the Cortex-M family of processors. Alternatively, a compact Arduino board like the mini or 
							micro could be used. Powering up from a 7.4V 1200mAh Li-ion battery that came with the RC car, a handy slide switch controls 
							the power, allowing for easy on/off toggling. Since the stock battery is now used for the transmitter, the RC car's main power 
							now relies on an externally bought higher-capacity battery.</p>
							<p>The NRF24L01+PA+LNA module, joysticks, and potentiometer are all connected to a 3.3V power 
							source. It's crucial to connect the NRF24L01 module specifically to 3.3V to avoid damage. Opting for 3.3V for the joysticks 
							and potentiometer yields better analog readings compared to 5V. The toggle switch is connected to 5V.</p>
							<p>In terms of functionality, the left joystick exclusively handles forward or backward throttle through its VRy pin, while 
							the right joystick, responsible for turning, interfaces only with VRx. To enhance the NRF24L01 module's reliability, a 10uF 
							decoupling capacitor is placed across its power lines, contributing to overall reliability.</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/transmitter_circuit.png" alt="" />
						</div>
					</section>

				<!-- Three -->
					<section class="spotlight style1 orient-left content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Receiver Circuit Diagram</h2>
							<p>Once again, the NUCLEO-L432KC finds its place on the receiver side. As described earlier, the power source 
								for the RC car comes from a 7.4V 2000mAh Li-ion battery, a significant upgrade from the stock 1200mAh battery, improving the 
								overall runtime. The NRF24L01+ module (without PA+LNA) is connected to 3.3V, featuring another 
								decoupling capacitor similar to the transmitter. The HC-SR04 module operates on 5V. The motor wires are desoldered from the old 
								motor driver and connected to the new DC motor driver.</p> 
								<p>For Motor 1, the interface involves ENA1, IN1, and IN2, 
								while Motor 2 interfaces through ENA2, IN3, and IN4. Each set of pins correspond to PWM and I/O functions for its 
								respective motor. Additionally, the power supply for the motor driver is drawn from the same 7.4V battery powering the 
								microcontroller.</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/receiver_circuit.png" alt="" />
						</div>
					</section>

				<!-- Four -->
					<section class="spotlight style1 orient-right content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Transmitter PCB Design</h2>
							<p>Here are the <a href="https://easyeda.com/editor#id=64a497a655c648d0b4b0406a234e0c97|bf4c7d610f5e4f019f44b5b8cc17287b">project files</a> 
								for the transmitter PCB, and I had it ordered through JCLPCB. I shaped the PCB with modern controllers in mind, focusing on 
								comfort during use.</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/transmitter_pcb.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->
					<section class="spotlight style1 orient-left content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Receiver PCB Design</h2>
							<p>Here are the <a href="https://easyeda.com/editor#id=ba25a94d2c4f42d08c662e365f6207d0|5ef33eac6a444b02bf72100dfc768694">project files</a>
								for the receiver PCB, and I had it ordered through JCLPCB. The idea was to keep it as compact as possible, ensuring a snug 
								fit inside the RC car enclosure.</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/receiver_pcb.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->	
					<section class="spotlight style1 orient-right content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Physical PCB's</h2>
							<p>The PCBs came back in excellent condition and of high quality. The use of these PCBs has 
								the added benefit of eliminating the need for numerous extra wires, preventing a cluttered and unreliable setup prone to wire 
								noise. The next step involved the satisfying process of soldering all the components onto both PCBs, followed by the assembly 
								of the controller using precision-cut acrylic and M3 spacers for a sleek and well-organized final look.</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/pcbs_real.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->	
					<section class="spotlight style1 orient-left content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Custom Cut Acrylic</h2>
							<p>The front and back covers for the transmitter PCB were created by laser cutting a 1/8in clear acrylic sheet in the shape of the PCB. 
							Here are the <a href = "downloadable_files/LaserCutFiles.zip" download>DXF files</a> for the laser printer.</p>	
						</div>
						<div class="image">
							<img src="images/gallery/design/acrylic.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->	
					<section class="spotlight style1 orient-right content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Assembled RC Car Transmitter </h2>
							<p>I soldered the components onto the PCB and attached the acrylic onto the PCB using two spacers: 
								a 5mm spacer at the back, secured with a nut, and a 10mm spacer at the front, held in place with a screw.  
								The battery is neatly fastened at the back, thanks to some trusty velcro. Now, the slide switch that powers the RC car 
								is super glued on the top, right between the back acrylic and the PCB. To make sure it stays put, I added a layer of tape
								on top of the acrylic and under the switch before applying the glue. This trick worked like a charm, preventing the switch 
								from constantly slipping off when directly glued to the acrylic.</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/four.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->	
					<section class="spotlight style1 orient-left content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Under the Hood</h2>
							<p>The motor driver and receiver PCB were tucked snugly under the outer shell of the RC car, as there wasn't really any other 
								good spot for them. This made it super easy to troubleshoot the microcontroller when needed. Up at the front of the car, 
								I used some glue to attach the ultrasonic sensor to a small piece of cardboard.</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/five.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->	
					<section class="spotlight style1 orient-right content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Looking Closer</h2>
							<p>Through this opening, the wires for the power and both motors are fed into the motor driver's two black terminals 
								as well as its green terminal. The green terminal is for power, and the black terminal is for the motors. Let's examine 
								the precise path taken by the cables to reach this area.</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/six.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->	
					<section class="spotlight style1 orient-left content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Uncovering the Next Sections</h2>
							<p>Let's dive in! After unscrewing the plate, the front motor and the old motor driver (not shown in the picture) are
								revealed. After desoldering the wires from the old motor driver, I connected them to the new one. Check out the yellow 
								circle; those are the wires coming from the battery tucked beneath the car. Now, focus on the red circle – four wires 
								sneak under another plate. Lift it, and you'll uncover a set of wires connected to the slide switch (that's for power) and 
								another set leading to the back motor.</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/seven.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->	
					<section class="spotlight style1 orient-right content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Securing the Receiver PCB</h2>
							<p>The PCB is secured inside of the protective cage of the RC car – a perfect fit!</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/eight.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->	
					<section class="spotlight style1 orient-left content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Securing the Motor Driver</h2>
							<p>I placed the motor driver right behind the PCB, which also fit perfectly. After that, the top piece of the RC car went back 
								into place. Notice the red circle? That's a part of the cage that I cut to create room for the Micro-B USB cable to reach 
								the microcontroller's debug port.</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/three.png" alt="" />
						</div>
					</section>
								
				<!-- Five -->	
					<section class="spotlight style1 orient-right content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>A Look at the Bottom</h2>
							<p>The new battery I used to power the RC car was a bit too large to fit under the battery case – it just bulged out slightly 
								too much. So, here's the clever fix: I cut a piece of velcro into the shape of the bottom of the RC car and stuck it to 
								the outer lining. Then, I used the other side of the velcro as a makeshift outer case. Problem solved!</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/two.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->	
					<section class="spotlight style1 orient-left content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>The Final Design</h2>
							<p>Take a look – the RC car maintains its original look from the outside, almost unchanged. And the new electrical components 
								under the shell? They're neatly tucked away, not sticking out one bit. A stealthy upgrade!</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/one.png" alt="" />
						</div>
					</section>
					
				<!-- Additional Elements -->
					<section class="wrapper style1 align-center">
						<div class="inner">
							<h2>Important Code Snippets</h2>
							<p>Full code <a href="https://github.com/MoeeMan/STM32-RC-Car">here</a>. 
								nRF24L01+ Transceiver Library <a href="https://github.com/LonelyWolf/stm32/tree/master/nrf24l01">here</a>. </p>		
							<div class="index align-left">
							
								<!-- Code -->
									<section>
										<header>
											<h3>transmitter main.c</h3>
											<p>DMA is used to pipe the data between ADC and memory so that the CPU doesn't get bogged down and overwhelmed. 
												The three ADC values that we need are from the left joystick, right joystick, and potentiometer. One task is 
												created to transmit the data.</p>
										</header>
										
										<div class="content">
											<pre><code>//start adc in dma mode for multichannel
HAL_ADC_Start_DMA(&hadc1, VR, 3);

status = xTaskCreate(transmit_task, "transmit_task", 200, NULL, 4, &transmit_task_handle);
configASSERT(status == pdPASS);

vTaskStartScheduler();
</code></pre>
										</div>
									</section>
							
								<!-- Code -->
									<section>
										<header>
											<h3>transmitter.c</h3>
											<p>The NRF24L01 module is first initialized for transmission. The payload is filled with data from
												both joysticks, the potentiometer, and the toggle switch (enable/disable obstacle detection).
												The payload is then transmitted to the receiver.</p>
										</header>
										
										<div class="content">
											<pre><code>// Initialize the nRF24L01 to its default state
init_transmitter();

while(1)
{
	//Left joystick y-axis
	nRF24_payload[0] = (VR[0] >> 8) & 0xFF;
	nRF24_payload[1] = VR[0] & 0xFF;

	//Right joystick x-axis
	nRF24_payload[2] = (VR[1] >> 8) & 0xFF;
	nRF24_payload[3] = VR[1] & 0xFF;

	//Potentiometer
	nRF24_payload[4] = (VR[2] >> 8) & 0xFF;
	nRF24_payload[5] = VR[2] & 0xFF;


	enable_ultrasonic = HAL_GPIO_ReadPin(Switch_GPIO_Port, Switch_Pin) ? 0 : 1;

	//Switch
	nRF24_payload[6] = enable_ultrasonic;

	//Left Joystick Button Press
	nRF24_payload[7] = toggleHeadlights;
	if(toggleHeadlights)
	{
		UART_SendStr("TOGGLE");
		UART_SendStr("\r\n");
		toggleHeadlights = 0;
	}

	//the nRF24 is ready for transmission, upload a payload,
	//then pull CE pin to HIGH and it will transmit a packet...
	tx_res = nRF24_TransmitPacket(nRF24_payload,payload_length);
</code></pre>
										</div>
									</section>
					
								<!-- Code -->
									<section>
										<header>
											<h3>receiver main.c</h3>
											<p>htim1 is used for the PWM generation, while htim2 is used for the ultrasonic sensor.
												Three tasks are created: one to receive input from the transmitter, another to run the ultrasonic
												sensor obastacle detecting code, and then the last to run the motor. The event queue is created
												to receive events from either the transmitter or ultrasonic sensor, which are then used in the 
												motor task.</p>
										</header>
										
										<div class="content">
											<pre><code>HAL_TIM_Base_Start(&htim1);						
HAL_TIM_Base_Start(&htim2);

HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);  //Start pwm back motor 100% duty cycle
HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);  //Start pwm front motor 100% duty cycle

status = xTaskCreate(receive_task, "receive_task", 500, NULL, 3, &receive_task_handle);
configASSERT(status == pdPASS);

status = xTaskCreate(ultrasonic_task, "ultrasonic_task", 500, NULL, 5, &ultrasonic_task_handle);
configASSERT(status == pdPASS);

status = xTaskCreate(motor_task, "motor_task", 500, NULL, 4, &motor_task_handle);
configASSERT(status == pdPASS);

eventQueue = xQueueCreate(2, sizeof(QUEUE_DATA));
configASSERT(eventQueue != NULL);

vTaskStartScheduler();
</code></pre>
										</div>
									</section>
									
								<!-- Code -->
									<section>
										<header>
											<h3>receiver.c</h3>
											<p>The NRF24L01 module is first initialized for receiving. The receiver continuously checks the 
												FIFO for a payload from the transmitter. The data is saved to their respective variables and 
												then packaged together as a "Joystick" event, which is sent to the event queue.</p>
										</header>
										
										<div class="content">
											<pre><code>// Initialize the nRF24L01 to its default state
init_receiver();

while (1) {
	// Constantly poll the status of the RX FIFO and get a payload if FIFO is not empty
	if (nRF24_GetStatus_RXFIFO() != nRF24_STATUS_RXFIFO_EMPTY) {
		// Get a payload from the transceiver
		pipe = nRF24_ReadPayload(nRF24_payload, &payload_length);

		VRy |= nRF24_payload[0] << 8;
		VRy |= nRF24_payload[1];
		VRx |= nRF24_payload[2] << 8;
		VRx |= nRF24_payload[3];

		throttle_limit |= nRF24_payload[4] << 8;
		throttle_limit |= nRF24_payload[5];

		enable_ultrasonic = nRF24_payload[6];

		toggleHeadlights = nRF24_payload[7];

		q_data.eventType = JOYSTICK;
		q_data.data[0] = VRy;
		q_data.data[1] = VRx;
		q_data.data[2] = throttle_limit;
		q_data.data[3] = enable_ultrasonic;
		q_data.data[4] = toggleHeadlights;

		if(!enable_ultrasonic)
			vTaskSuspend(ultrasonic_task_handle);
		else
			vTaskResume(ultrasonic_task_handle);
			
		xQueueSend(eventQueue, &q_data, portMAX_DELAY);
	}
}
</code></pre>
										</div>
									</section>
									
								<!-- Code -->
									<section>
										<header>
											<h3>ultrasonic.c</h3>
											<p>The ultrasonic task sends out a high Trig pulse and starts the htim2 timer. It waits until
												Echo goes low and then calculates the distance. Now instead of using this distance reading in
												the obstacle detection code, it is used in store_reading. The store_reading() algorithm takes five
												distance readings of the ultrasonic sensor and computes the median of those values. This is
												done to prevent false readings and increase reliability. The algorithm used to sort these
												values is a bitonic sort with five inputs. The median value is packaged as an "Ultrasonic" event,
												which is sent to the event queue.</p>
										</header>
										
										<div class="content">
											<pre><code>void ultrasonic_task(void *param)
{
	while(1){
		HAL_GPIO_WritePin(Trig_GPIO_Port, Trig_Pin, GPIO_PIN_RESET);
		delay_us(2);

		HAL_GPIO_WritePin(Trig_GPIO_Port, Trig_Pin, GPIO_PIN_SET);
		delay_us(10);
		HAL_GPIO_WritePin(Trig_GPIO_Port, Trig_Pin, GPIO_PIN_RESET);

		while(!HAL_GPIO_ReadPin(Echo_GPIO_Port, Echo_Pin))
		{
			//wait until echo goes high
			x1 = __HAL_TIM_GET_COUNTER(&htim2);
		}

		while(HAL_GPIO_ReadPin(Echo_GPIO_Port, Echo_Pin))
		{
			//wait until echo goes low
			x2 = __HAL_TIM_GET_COUNTER(&htim2);
		}

		//calculate distance
		dist = (x2-x1) * 0.034/2;

		store_reading(dist);
	}
}

void delay_us(uint16_t delay)
{
	__HAL_TIM_SET_COUNTER(&htim2,0);
	while(__HAL_TIM_GET_COUNTER(&htim2) < delay);
}

#define CMP_SWAP(i, j) if (dist_readings[i] > dist_readings[j]) \
	{ int tmp = dist_readings[i]; dist_readings[i] = dist_readings[j]; dist_readings[j] = tmp; }
#define MAX_READINGS	5

void store_reading(uint16_t dist)
{
	dist_readings[i] = dist;
	i++;

	//array full. Only works for 5 entries
	if(i == MAX_READINGS)
	{
		CMP_SWAP(0, 3); CMP_SWAP(1, 4); CMP_SWAP(0, 2); CMP_SWAP(1, 3);
		CMP_SWAP(0, 1); CMP_SWAP(2, 4); CMP_SWAP(1, 2); CMP_SWAP(3, 4);
		CMP_SWAP(2, 3);

		median_dist = dist_readings[MAX_READINGS/2];
		i=0;
		memset(dist_readings, 0, sizeof(dist_readings));

		q_data.eventType = ULTRASONIC;
		q_data.data[0] = median_dist;

		if(firstReading)
		{
			t1 = HAL_GetTick();
			firstDist = dist;
			firstReading = 0;
		}
		else
		{
			t2 = HAL_GetTick();
			temp = (int)(t2 - t1) / (double)1000;
			speed = (firstDist - dist) / temp;
			speedArray[idx] = speed;
			idx = (idx+1) % 100;
			firstReading = 1;
		}

		//send to front because its important. Dont block if queue is full
		xQueueSendToFront(eventQueue, &q_data, ( TickType_t ) 0);

		vTaskDelay(150);
	}
}
</code></pre>
										</div>
									</section>
									
								<!-- Code -->
									<section>
										<header>
											<h3>motor.c</h3>
											<p>The motor task can receive "Joystick" or "Ultrasonic" events and process each one differently.
												In a "Joystick" event, the values from the joystick and potentiometer (throttle control) are 
												used together in throttleToPwm() to find the final pwm value that should be used to move left, 
												right, forward, or
												backward. When moving forward and backward, calcDelay() is used to prevent quick changes in
												those directions, which can cause damage to the motors and motor driver. In an "Ultrasonic"
												event, the median distance value is used to choose whether to stop or continue forward
												(if enable_ultrasonic is set from the toggle switch of the transmitter). calcStopDistance()
												is used to calculate the stopping distance from an object based on how fast the car is moving. 
												In other words, if the car is moving fast, it stops much sooner than if it were moving slowly. 
												This algorithm is far from efficient, as I used trial and error at different speeds. A better 
												approach is to use an accelerometer and gyroscope sensor.</p>
										</header>
										
										<div class="content">
											<pre><code>#define DEFAULT_X		2000
#define DEFAULT_Y		2000
#define THRESHOLD_AXIS		30
#define MAX_PWM			(htim1.Init.Period)
#define MIN_PWM_PERC		.1
#define MAX_THROTTLE		4038

typedef enum {
	BRAKE = 0,
	FORWARD = 1,
	BACKWARD = 2
} Direction;

void motor_task(void *param)
{
	while(1)
	{
		status = xQueueReceive(eventQueue, &q_data, portMAX_DELAY);
		if(status == pdTRUE)
		{
			if(q_data.eventType == JOYSTICK)
			{
				posY = q_data.data[0];
				posX = q_data.data[1];
				throttle_limit = q_data.data[2];
				enable_ultrasonic = q_data.data[3];
				toggleHeadlights = q_data.data[4];

				if(toggleHeadlights)
					HAL_GPIO_TogglePin(HeadLights_GPIO_Port, HeadLights_Pin);

				stop = enable_ultrasonic ? stop : 0;

				newMaxPwm = ((double)throttle_limit / MAX_THROTTLE) * MAX_PWM;
				minPwm = newMaxPwm * MIN_PWM_PERC;


				HAL_GPIO_WritePin(PWMB_GPIO_Port, PWMB_Pin, GPIO_PIN_SET);
				//Turn Right
				if(posX >= DEFAULT_X+THRESHOLD_AXIS)
				{
					HAL_GPIO_WritePin(FrontMotor_IN1_GPIO_Port, FrontMotor_IN1_Pin, GPIO_PIN_SET);
					HAL_GPIO_WritePin(FrontMotor_IN2_GPIO_Port, FrontMotor_IN2_Pin, GPIO_PIN_RESET);
				}
				//Turn Left
				else if(posX <= DEFAULT_X-THRESHOLD_AXIS)
				{
					HAL_GPIO_WritePin(FrontMotor_IN1_GPIO_Port, FrontMotor_IN1_Pin, GPIO_PIN_RESET);
					HAL_GPIO_WritePin(FrontMotor_IN2_GPIO_Port, FrontMotor_IN2_Pin, GPIO_PIN_SET);
				}
				//No turn
				else if(posX < DEFAULT_X+THRESHOLD_AXIS || posX > DEFAULT_X-THRESHOLD_AXIS)
				{
					HAL_GPIO_WritePin(FrontMotor_IN1_GPIO_Port, FrontMotor_IN1_Pin, GPIO_PIN_SET);
					HAL_GPIO_WritePin(FrontMotor_IN2_GPIO_Port, FrontMotor_IN2_Pin, GPIO_PIN_SET);
				}

				//Forward
				if((posY <= DEFAULT_Y-THRESHOLD_AXIS) && !stop)
				{
					dirDelay = HAL_GetTick() - lastDirDelay;
					maxDirDelay = calcDelay(pwmY);
					if(state == BACKWARD && (dirDelay < maxDirDelay))
					{
						state = BRAKE;
						brake();
						vTaskDelay(maxDirDelay - dirDelay);
					}
					else
					{
						state = FORWARD;
						pwmY = throttleToPwm(posY);
						throttle(pwmY);
					}
				}
				//Backward
				else if(posY >= DEFAULT_Y+THRESHOLD_AXIS)
				{
					dirDelay = HAL_GetTick() - lastDirDelay;
					maxDirDelay = calcDelay(pwmY);
					if(state == FORWARD && (dirDelay < maxDirDelay))
					{
						state = BRAKE;
						brake();
						vTaskDelay(maxDirDelay - dirDelay);
					}
					else
					{
						state = BACKWARD;
						pwmY = throttleToPwm(posY);
						throttle(pwmY);
					}
				}
				//Brake
				else if(posY < DEFAULT_Y+THRESHOLD_AXIS || posY > DEFAULT_Y-THRESHOLD_AXIS)
				{
					brake();
				}
			}
			else if(q_data.eventType == ULTRASONIC && enable_ultrasonic)
			{
				stopDistance = calcStopDistance(pwmY);
				median_dist = q_data.data[0];
				if(median_dist > stopDistance && !stop)
				{
					stop = 0;
				}
				else if((median_dist <= stopDistance))
				{
					stop = 1;
				}
				//avoid flickering between red and green
				else if(median_dist > stopDistance+3 && stop)
				{
					stop = 0;
				}
			}
		}
	}
}

uint32_t throttleToPwm(uint32_t adcVal)
{
	int a = 4035 - (DEFAULT_Y+THRESHOLD_AXIS);	//a=2000
	double b = abs(adcVal - (DEFAULT_Y+THRESHOLD_AXIS));
	double c = (b / a) * (1-MIN_PWM_PERC);
	uint32_t newPwm = minPwm + (newMaxPwm * c);

	return newPwm;
}

uint32_t calcDelay(uint32_t pwmY)
{
	uint32_t delay = 100;
	if(pwmY > MAX_PWM/2)
		delay += ((pwmY/10)*4);

	return delay;
}

uint32_t calcStopDistance(uint32_t pwmY)
{
	uint32_t distance = 10;
	distance += pwmY/8;

	return distance;
}

void brake(void)
{
	HAL_GPIO_WritePin(BackMotor_IN1_GPIO_Port, BackMotor_IN1_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(BackMotor_IN2_GPIO_Port, BackMotor_IN2_Pin, GPIO_PIN_RESET);
	__HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, 0);
}

void throttle(uint32_t pwmY)
{
	if(state == FORWARD)
	{
		HAL_GPIO_WritePin(BackMotor_IN1_GPIO_Port, BackMotor_IN1_Pin, GPIO_PIN_RESET);
		HAL_GPIO_WritePin(BackMotor_IN2_GPIO_Port, BackMotor_IN2_Pin, GPIO_PIN_SET);
	}
	else if(state == BACKWARD)
	{
		HAL_GPIO_WritePin(BackMotor_IN1_GPIO_Port, BackMotor_IN1_Pin, GPIO_PIN_SET);
		HAL_GPIO_WritePin(BackMotor_IN2_GPIO_Port, BackMotor_IN2_Pin, GPIO_PIN_RESET);
	}

	__HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, pwmY);
	lastDirDelay = HAL_GetTick();
}
</code></pre>
										</div>
									</section>
									
							</div>
						</div>
					</section>
									
				<!-- Additional Elements -->
					<section class="wrapper style1 align-center">
						<div class="inner">
							<h2>Additional Items</h2>
							<div class="index align-left">
						
								<!-- Table -->
									<section>
										<header>
											<h3>Motor Driver Control Signal Logic</h3>
										</header>
										<div class="content">
											<div class="table-wrapper">
												<table class="alt">
													<thead>
														<tr>
															<th>IN1</th>
															<th>IN2</th>
															<th>ENA</th>
															<th>OUT</th>
														</tr>
													</thead>
													<tbody>
														<tr>
															<td>0</td>
															<td>0</td>
															<td>X</td>
															<td>Brake</td>
														</tr>
														<tr>
															<td>1</td>
															<td>1</td>
															<td>X</td>
															<td>Floating</td>
														</tr>
														<tr>
															<td>1</td>
															<td>0</td>
															<td>PWM</td>
															<td>Forward to speed</td>
														</tr>
														<tr>
															<td>0</td>
															<td>1</td>
															<td>PWM</td>
															<td>Backward to speed</td>
														</tr>
														<tr>
															<td>1</td>
															<td>0</td>
															<td>1</td>
															<td>Full speed forward</td>
														</tr>
														<tr>
															<td>0</td>
															<td>1</td>
															<td>1</td>
															<td>Full speed backward</td>
														</tr>
													</tbody>
												</table>
											</div>

										</div>
									</section>
									
								<!-- Table -->
									<section>
										<header>
											<h3>Bitonic Sort with 5 Inputs</h3>
										</header>
										<div class="image">
											<img src="images/gallery/design/bitonic_sort.png" alt="" />
										</div>
									</section>
								
							</div>
						</div>
					</section>
					
				<!-- Challenges -->
					<section class="wrapper style1 align-center">
						<div class="inner">
							<h2>Challenges</h2>
							<div class="index align-left">
						
								<!-- Motor Driver Selection -->
									<section>
										<header>
											<h3>Motor Driver Selection</h3>
										</header>
										<div class="content">
											<p>The initial problem I encountered was a pulsing effect in the motor when quickly changing 
												directions or driving at a high speed. Check out the video below to see what I mean. I experimented 
												with various motor drivers: the TB6612FNG, DRV8833, and MX1508, but none resolved the issue. After a bit 
												of research, I realized the motors were drawing too much current, triggering the thermal shutdown 
												circuit in the motor drivers.</p>
											<p>Enter the DROK L298 motor driver. Although a bit bulkier, this powerhouse 
												(Output current: 7A average/50A peak) effortlessly handled the current demands of the motors, putting an 
												end to the pulsing problem. It became the unsung hero of this project, ensuring smooth motor operation 
												without breaking a sweat.</p>
											<video width="285" height="500" controls>
											  <source src="videos/badMotorDriver.mp4" type="video/mp4">										 
											Your browser does not support the video tag.
											</video>
										</div>
									</section>
									
								<!-- RC Car Selection -->
									<section>
										<header>
											<h3>RC Car Selection</h3>
										</header>
										<div class="content">
											<p>So, I got the cheapest RC car on Amazon, only to realize that it ran on a 3.7V battery. I was set 
												on using a 7.4V power supply for both the STM32 and motor driver. Here's the problem: doubling the voltage 
												would certainly burn out the motors. After some digging around, I learned that using PWM at a 50% duty cycle 
												could mimic a 3.7V power source, as long as the PWM switching frequency is high enough to prevent current 
												saturation. This trick worked, but it capped the RC car's speed at 50%, not exactly ideal.</p>
											<p>Next, I thought, "Why not replace the motors for ones rated at a higher voltage?" Well, that turned out to be 
												a real headache. The stock motors were a perfect fit, and swapping them meant shaving down some plastic. 
												Even then, the new motors didn't sit comfortably in their enclosures. Finally, the lightbulb moment hit me – 
												why not just use a different RC car that already comes with a 7.4V battery? Sometimes, the simplest solution 
												is the best one!</p>

										</div>
									</section>
									
								<!-- NRF24L01 Problems-->
									<section>
										<header>
											<h3>NRF24L01 Problems</h3>
										</header>
										<div class="content">
											<p>Trying to get both transceivers to work together properly was also a process. Some things I found 
												to work in my case are the following:</p>
											<ul>
												<li>As mentioned earlier, soldering a 10uF capacitor on the power lines for both modules</li>
												<li>Setting the SPI baud rate to 1.25Mb/s</li>
												<li>Setting the data rate to 250kbps for both modules</li>
												<li>Setting the RF channel to 115 (2515MHz) for both modules</li>
												<li>Setting the RF power of the module in transmit mode to -12dBm</li>
												<li>Make sure the TX/RX addresses match</li>
												<li>Make sure the address lengths are set correctly</li>
												<li>Make sure the payload lengths match for both TX/RX</li>
												<li>Adding a 100ms delay after transmitting</li>
											</ul>
											<p>Some of these may or may not be the same in everyone's scenario, so trial and error would be
											the best approach.</p>
										</div>
									</section>
									
							</div>
						</div>
					</section>
					
				<!-- Demo Videos -->
					<section class="wrapper style1 align-center">
						<div class="inner">
							<h2>Demo Videos</h2>
						</div>

						<!-- Demo Videos -->
							<div class="gallery style1 small lightbox onscroll-fade-in">
								<article>
									<video width="285" height="500" controls>
										<source src="videos/normal.mp4" type="video/mp4">										 
									</video>
									<div class="caption">
										<h3>Driving Normal</h3>
										<p>Throttle knob is set in the middle.</p>
									</div>
								</article>
								<article>
									<video width="285" height="500" controls>
										<source src="videos/slow.mp4" type="video/mp4">										 
									</video>
									<div class="caption">
										<h3>Driving Slow</h3>
										<p>Throttle knob is set lower.</p>
									</div>
								</article>
								<article>
									<video width="285" height="500" controls>
										<source src="videos/fast.mp4" type="video/mp4">										 
									</video>
									<div class="caption">
										<h3>Driving Fast</h3>
										<p>Throttle knob is set higher.</p>
									</div>
								</article>
								<article>
									<video width="285" height="500" controls>
										<source src="videos/obstacleDetecting1.mp4" type="video/mp4">										 
									</video>
									<div class="caption">
										<h3>Obstacle Detecting 1</h3>
										<p>Toggle switch is turned on to detect obstacles.</p>
									</div>
								</article>
								<article>
									<video width="285" height="500" controls>
										<source src="videos/obstacleDetecting2.mp4" type="video/mp4">										 
									</video>
									<div class="caption">
										<h3>Obstacle Detecting 2</h3>
										<p>Toggle switch is turned on to detect obstacles.</p>
									</div>
								</article>
								<article>
									<video width="285" height="500" controls>
										<source src="videos/noObstacleDetecting.mp4" type="video/mp4">										 
									</video>
									<div class="caption">
										<h3>No Obstacle Detecting</h3>
										<p>Toggle switch is turned off to not detect obstacles.</p>
									</div>
								</article>
							</div>

					</section>
					
					
				<!-- Footer -->
					<footer class="wrapper style1 align-center">
						<div class="inner">
							<p>&copy; Muhmin Abdeljaber/STM32 RC Car 2023 | All rights reserved.</p>
						</div>
					</footer>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>