<!DOCTYPE HTML>
<!--
	Story by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>index.html</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper" class="divided">

				c
					<section class="banner style1 orient-left content-align-left image-position-right fullscreen onload-image-fade-in onload-content-fade-right">
						<div class="content">
							<h1>STM32 RC Car</h1>
							<p class="major">A project by Muhmin Abdeljaber.</p>
							<ul class="actions stacked">
								<li><a href="#first" class="button big wide smooth-scroll-middle">Get Started</a></li>
							</ul>
						</div>
						<div class="image">
							<img src="images/gallery/design/cover.png" alt="" />
						</div>
					</section>
					
				<!-- Overview -->
					<section class="wrapper style1 align-center" id="first">
						<div class="inner">
							<h2>Overview</h2>
							<p>A couple of years ago, I began a to work on a fun RC car project using one of those basic Arduino kits 
								like the one below.</p>
								<div class="image">
									<img src="images/gallery/design/old_rc_car.png" alt="" />
								</div>
							<p>Looking back, I didn't really have much experience in most of what was involved in this project like
								interrupt events, power supplies, motor drivers, and wireless communication. The first thing that was wrong
								was the power supply and motor driver. To start out, I attempted to 
								get the RC car to move in various directions to make sure the motors were working correctly. Here, I was using 4 AA 
								batteries (6V) and a L298N motor driver, <i><b><u>to power 4 motors.</u></b></i> With the voltage drop of 2V in the 
								L298N (even more at higher loads), running 4 motors on two channels of this motor driver barely caused the car to move. 
								With this issue not solved, I decided to skip the bluetooth communication for the receiver/transmitter and convert 
								this project into an obstacle avoidance robot. Now the car was able to avoid obstacles using an ultrasonic sensor, but
								I did not implement any interrupts and instead used polling for the entirety of the code, which was fine in this scenario as
								there was only one sensor that was polled. This is where my project ended.</p>
								<p>Fast forward to the present, I decided to revisit this project and try to solve the issues I faced before to actaully create 
								a viable RC car by introducing a transmitter/receiver. Having had experience with Cortex M4 processor, I decided to use a 
								STM32 board instead of an Arduino. Since there were going to be many things going on at once, polling wouldn't suffice, so I 
								decided to use RTOS instead. Moments before ordering another RC car kit to begin this project, I randomly stumbled upon a 
								better approach. This approach involved using a cheap commercially bought RC car and modifying it so that it could be controlled 
								with a custom built transmitter. This allows us to use the internal and external frame of the RC car for both appearance 
								and functionality. Both of these ideas are given credit to Dejan at HowToMechatronics which include the 
								<a href="https://howtomechatronics.com/projects/diy-arduino-rc-receiver/">RC car modification</a> and
								<a href="https://howtomechatronics.com/projects/diy-arduino-rc-transmitter/">custom transmitter</a>.</p>						
						</div>
					</section>
					
				<!-- Six -->
					<section class="wrapper style2 align-center">
						<div class="inner">
							<h2>Components List</h2>
							<h3>Receiver</h3>
							<div class="items style1 medium onscroll-fade-in">
								<section>
									<div class="image">
										<img src="images/gallery/receiver/rc_car.png" alt="" />
									</div>
									<h3>RC Car</h3>
									<p>Bought from Amazon. Equipped with a 280 brushed DC motor, DC motor driver, and a 7.4V 1200mAh battery. 
										If another RC car is used, make sure the motor is brushed (not brushless with an ESC) and is compatible with 7.4V.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/receiver/l432kc.png" alt="" />
									</div>
									<h3>NUCLEO-L432KC</h3>
									<p>The microcontroller used with STM32CubeIDE.</p>
									<p>Features: Arm 32-bit Cortex-M4 CPU, 32 kHz crystal oscillator for RTC, 256KB flash, 
										64KB of SRAM,14x communication interfaces, and a 14-channel DMA controller.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/receiver/motor_driver.png" alt="" />
									</div>
									<h3>DROK L298 Dual H Bridge DC Motor Driver</h3>
									<p>Voltage range is DC 6.5V-27V, rated output current of each port is 7A, 160W total output power, 
										PWM frequency range 0-10kHz, under voltage protection.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/receiver/nrf24l01.png" alt="" />
									</div>
									<h3>NRF24L01+</h3>
									<p>Single chip 2.4GHz transceiver.</p> 
									<p>Data transfer rate is configurable to 250kbps, 1Mbps, or 2Mbps, operating voltage range 1.9V-3.9V, 
										output power is configurable to 0 dBm, -6 dBm, -12 dBm, or -18 dBm, 
										communicates over a 4-pin SPI with a maximum data rate of 10Mbps.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter/capacitor.png" alt="" />
									</div>
									<h3>10uF Capacitor</h3>
									<p>Soldered between the power lines of the NRF24L01+ module to improve reliability.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/receiver/ultrasonic.png" alt="" />
									</div>
									<h3>HC-SR04</h3>
									<p>Ultrasonic distance sensor. Operating range of 2cm-400cm with an accuracry of 0.3cm. 5V operating voltage.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/receiver/battery.png" alt="" />
									</div>
									<h3>URGENEX 7.4V 2000mAh Li-ion Battery</h3>
									<p>Used to power the RC car instead of the stock battery it came with. The stock battery is used for the transmitter.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/receiver/pcb.png" alt="" />
									</div>
									<h3>Custom PCB</h3>
									<p>Designed in EasyEDA.</p>
								</section>
							</div>
							
							<h3>Transmitter</h3>
							<div class="items style1 medium onscroll-fade-in">
								<section>
									<div class="image">
										<img src="images/gallery/transmitter/l432kc.png" alt="" />
									</div>
									<h3>NUCLEO-L432KC</h3>
									<p>The microcontroller used with STM32CubeIDE.</p>
									<p>Features: Arm 32-bit Cortex-M4 CPU, 32 kHz crystal oscillator for RTC, 256KB flash, 
										64KB of SRAM,14x communication interfaces, and a 14-channel DMA controller.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter/joystick.png" alt="" />
									</div>
									<h3>2x Joystick</h3>
									<p>Left joystick is used for the Y-axis (throttle for back motor) and the right joystick is used for 
										the X-axis (turning for front motor )</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter/nrf24l01+pa+lna.png" alt="" />
									</div>
									<h3>NRF24L01+PA+LNA</h3>
									<p>Same as the normal module but includes a range extender chip that combines PA, LNA, and transmit-receive switching 
										circuitry. This enables the module to extend its transmission range up to 1000 meters.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter/capacitor.png" alt="" />
									</div>
									<h3>10uF Capacitor</h3>
									<p>Soldered between the power lines of the NRF24L01+PA+LNA module to improve reliability.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter/potentiometer.png" alt="" />
									</div>
									<h3>Potentiometer</h3>
									<p>Used for throttle control.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter/toggle_switch.png" alt="" />
									</div>
									<h3>SPDT Toggle Switch</h3>
									<p>Used to toggle the obstacle avoidance (HC-SR04) on/off.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter/slide_switch.png" alt="" />
									</div>
									<h3>SPDT Slide Switch</h3>
									<p>On/off switch for the RC car power.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter/battery.png" alt="" />
									</div>
									<h3>7.4V 1200mAh Li-ion Battery</h3>
									<p>Stock battery that came with the RC car. Used to power the transmitter instead.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter/pcb.png" alt="" />
									</div>
									<h3>Custom PCB</h3>
									<p>Designed in EasyEDA.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter/acrylic.png" alt="" />
									</div>
									<h3>1/8in Clear Acrylic Sheet</h3>
									<p>Cut in the shape of the PCB. Holes are also cut for the joysticks, potentiometer, and toggle switch to pass through.</p>
								</section>
								<section>
									<div class="image">
										<img src="images/gallery/transmitter/spacers.png" alt="" />
									</div>
									<h3>M3 Hex Spacers</h3>
									<p>Used to secure the custom cut acrylic to the PCB.</p>
								</section>
							</div>
						</div>
					</section>		

				<!-- Two -->
					<section class="spotlight style1 orient-right content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Transmitter Circuit Diagram</h2>
							<p>The brains of this project comes from the NUCLEO-L432KC microcontroller. This was mainly chosen based on its 
								small size, having an on-board ST-LINK for easy debugging, and I wanted to work in the Cortex-M family 
								of processors. A similar approach is to use an small Arduino board like the mini or micro. The power to Vin comes
								from a 7.4V 1200mAh Li-ion battery that came with the RC car I purchased. Its connected to a slide switch to easily
								turn the power on/off anytime. So the power for the RC Car
								uses a higher capacity battery that was purchased externally (see below). The NRF24L01+PA+LNA module, 
								joysticks, and the 
								potentiometer are all connected to 3.3V. Be sure to connect the NRF24L01 module to 3.3V as it will be 
								damaged if connected to 5V or Vin. As for the joysticks and potetiometer, I chose 3.3V as it gave me 
								much better analog readings than 5V. The toggle switch is also connected to 5V. The left joystick is stricly used
								to throttle forward or backward so it is only connected on its VRy pin. The right joystick is for turning so
								VRx is only connected. There is a 10uF decoupling capacitor across the power lines of the NRF24L01 module 
								which makes the reliability much better.</p>
						</div>
						<div class="image">
							<img src="images/gallery/transmitter/transmitter_circuit.png" alt="" />
						</div>
					</section>

				<!-- Three -->
					<section class="spotlight style1 orient-left content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Receiver Circuit Diagram</h2>
							<p>The NUCLEO-L432KC is again used on the receiver side. As described above, the power for the RC car comes from
								a seperate 7.4V 2000mAh Li-ion battery which increases the runtime signficantly compared to the stock 
								1200mAh battery. Here, the NRF24L01+ module is used (without PA+LNA) which is again connected to 3.3V and 
								includes another decoupling capacitor. The HC-SR04 module is connected to 5V. The motor wires are now desoldered off 
								the old motor driver and
								connected to the new DC motor driver. Motor 1 interfaces with ENA1, IN1, and IN2, while motor 2 interfaces
								through	ENA2, IN3, and IN4. These pins correspond to PWM and I/O for each motor. Also, the power for the 
								motor driver is coming from the same 7.4V battery used to power the microcontroller.</p>
						</div>
						<div class="image">
							<img src="images/gallery/receiver/receiver_circuit.png" alt="" />
						</div>
					</section>

				<!-- Four -->
					<section class="spotlight style1 orient-right content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Transmitter PCB Design</h2>
							<p>Here are the <a href="https://easyeda.com/editor#id=64a497a655c648d0b4b0406a234e0c97|bf4c7d610f5e4f019f44b5b8cc17287b">project files</a> 
								for the transmitter PCB which was ordered through JCLPCB. The shape of the PCB was designed based on modern controllers for comfort.</p>
						</div>
						<div class="image">
							<img src="images/gallery/transmitter/transmitter_pcb.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->
					<section class="spotlight style1 orient-left content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Receiver PCB Design</h2>
							<p>Here are the <a href="https://easyeda.com/editor#id=ba25a94d2c4f42d08c662e365f6207d0|5ef33eac6a444b02bf72100dfc768694">project files</a>
								for the receiver PCB which was ordered through JCLPCB. The thought was to make this as small as possible to fit in the RC car
								enclosure.</p>
						</div>
						<div class="image">
							<img src="images/gallery/receiver/receiver_pcb.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->	
					<section class="spotlight style1 orient-right content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Physical PCB's</h2>
							<p>Both PCB's came back very clean with high quality. Using these PCB's elimates the need for many additional wires which would make
								everything look extremely messy and can cause some unreliability due to wire noise. It was time to solder all of the components 
								onto both PCB's (which was very satisfying) and then assemble the controller using the custom laser cut acrylic and M3 spacers.</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/pcbs_real.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->	
					<section class="spotlight style1 orient-left content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Custom Cut Acrylic</h2>
							<p>The front and back covers for the transmitter PCB were created by laser cutting a 1/8in clear acrylic sheet in the shape of the PCB. 
							Here are the <a href = "downloadable_files/LaserCutFiles.zip" download>DXF files</a> for the laser printer which can be downloaded. </p>	
						</div>
						<div class="image">
							<img src="images/gallery/design/acrylic.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->	
					<section class="spotlight style1 orient-right content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Assembled RC Car Transmitter </h2>
							<p>The components were soldered onto the PCB and two spacers were used between the acrylic and the PCB - a 5mm spacer on the back,
								and a 10mm spacer on the front. The back spacer is held with a nut while the front spacer is held with a screw. The battery is
								attached to the back with velcro. The slide switch for the power is super glued on the top between the back acrylic and PCB. Tape
								is also added under the switch for the glue to stick onto, as applying it directly to the acrlyic caused the switch to fall off
								repeatedly.</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/four.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->	
					<section class="spotlight style1 orient-left content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Under the Hood</h2>
							<p>Both the motor driver and recevier PCB were placed under the outside shell of the RC car as they didnt fit anywhere else and makes
								debugging the microcontroller conveniently easy to do. The ultrasonic sensor is glued to some cardboard at the front of the car.</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/five.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->	
					<section class="spotlight style1 orient-right content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Looking Closer</h2>
							<p>The wires for the power and both motors are passed through this hole into the two black terminals and green terminal of the motor driver. 
								The black terminals are for the motors while the green one is for the power. Lets see exactly how the wires are getting to this section.</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/six.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->	
					<section class="spotlight style1 orient-left content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Uncovering the Next Sections</h2>
							<p>Unscrewing the plate uncovers the front motor and the old motor driver (not shown here). After desoldering the wires from the old
								motor driver, they're connected to the new motor driver. The yellow circle shows the wires coming from the battery underneath the car.
								The red circle has 4 wires going under another plate. Uncovering that shows a set of wires (the power) connected to the slide switch
								and then another set of wires going to the back motor.</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/seven.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->	
					<section class="spotlight style1 orient-right content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Securing the Receiver PCB</h2>
							<p>The PCB is secured inside of the cage of the RC car shell which was an exact fit.</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/eight.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->	
					<section class="spotlight style1 orient-left content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>Securing the Motor Driver</h2>
							<p>The motor driver is then secured behind the PCB which was also an exact fit, and the outside shell is secured back in place. The red circle shows part of the cage
								that was cut to allow the Micro-B USB cable to pass through to the microcontrollers debugging port.</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/three.png" alt="" />
						</div>
					</section>
								
				<!-- Five -->	
					<section class="spotlight style1 orient-right content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>A Look at the Bottom</h2>
							<p>The new battery that was used to power the RC car instead of the stock battery didn't fit under the battery case. To solve this issue,
								a piece of velcro was cut and stuck to the outer lining of the bottom of the car. The other side of the velcro is then used as the
								outer case.</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/two.png" alt="" />
						</div>
					</section>
					
				<!-- Five -->	
					<section class="spotlight style1 orient-left content-align-left image-position-center onscroll-image-fade-in">
						<div class="content">
							<h2>The Final Design</h2>
							<p>As seen, the RC car looks sleek and the new electrical components under the shell are hidden and do not stick out at all.</p>
						</div>
						<div class="image">
							<img src="images/gallery/design/one.png" alt="" />
						</div>
					</section>
					
				<!-- Additional Elements -->
					<section class="wrapper style1 align-center">
						<div class="inner">
							<h2>Important Code Snippets</h2>
							<p>Full code <a href="https://github.com/MoeeMan/STM32-RC-Car">here</a>. 
								nRF24L01+ Transceiver Library <a href="https://github.com/LonelyWolf/stm32/tree/master/nrf24l01">here</a>. </p>		
							<div class="index align-left">
							
								<!-- Code -->
									<section>
										<header>
											<h3>transmitter main.c</h3>
											<p>DMA is used to pipe the data between ADC and memory so that the CPU doesn't slow down and 
												become overloaded. The three ADC values that we need is from the left joystick, right joystick,
												and potentiometer. One task is created to transmit the data.</p>
										</header>
										
										<div class="content">
											<pre><code>//start adc in dma mode for multichannel
HAL_ADC_Start_DMA(&hadc1, VR, 3);

status = xTaskCreate(transmit_task, "transmit_task", 200, NULL, 4, &transmit_task_handle);
configASSERT(status == pdPASS);

vTaskStartScheduler();
</code></pre>
										</div>
									</section>
							
								<!-- Code -->
									<section>
										<header>
											<h3>transmitter.c</h3>
											<p>The NRF24L01 module is first initialized for transmission. The payload is filled with data from
												both joysticks, the potentiometer, and the toggle switch (enable/disable obstacle detection).
												The payload is then transmitted to the receiver.</p>
										</header>
										
										<div class="content">
											<pre><code>// Initialize the nRF24L01 to its default state
init_transmitter();

while(1)
{
	//Left joystick y-axis
	nRF24_payload[0] = (VR[0] >> 8) & 0xFF;
	nRF24_payload[1] = VR[0] & 0xFF;

	//Right joystick x-axis
	nRF24_payload[2] = (VR[1] >> 8) & 0xFF;
	nRF24_payload[3] = VR[1] & 0xFF;

	//Potentiometer
	nRF24_payload[4] = (VR[2] >> 8) & 0xFF;
	nRF24_payload[5] = VR[2] & 0xFF;


	enable_ultrasonic = HAL_GPIO_ReadPin(Switch_GPIO_Port, Switch_Pin) ? 0 : 1;

	//Switch
	nRF24_payload[6] = enable_ultrasonic;

	//Left Joystick Button Press
	nRF24_payload[7] = toggleHeadlights;
	if(toggleHeadlights)
	{
		UART_SendStr("TOGGLE");
		UART_SendStr("\r\n");
		toggleHeadlights = 0;
	}

	//the nRF24 is ready for transmission, upload a payload,
	//then pull CE pin to HIGH and it will transmit a packet...
	tx_res = nRF24_TransmitPacket(nRF24_payload,payload_length);
</code></pre>
										</div>
									</section>
					
								<!-- Code -->
									<section>
										<header>
											<h3>receiver main.c</h3>
											<p>htim1 is used for the PWM generation while htim2 is used for the ultrasonic sensor.
												Three tasks are created: one to receive input from the transmitter, another to run the ultrasonic
												sensor obastacle detecting code, and then the last to run the motor. The event queue is created
												to receive events from either the transmitter or ultrasonic sensor, which is then used in the 
												motor task.</p>
										</header>
										
										<div class="content">
											<pre><code>HAL_TIM_Base_Start(&htim1);						
HAL_TIM_Base_Start(&htim2);

HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);  //Start pwm back motor 100% duty cycle
HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);  //Start pwm front motor 100% duty cycle

status = xTaskCreate(receive_task, "receive_task", 500, NULL, 3, &receive_task_handle);
configASSERT(status == pdPASS);

status = xTaskCreate(ultrasonic_task, "ultrasonic_task", 500, NULL, 5, &ultrasonic_task_handle);
configASSERT(status == pdPASS);

status = xTaskCreate(motor_task, "motor_task", 500, NULL, 4, &motor_task_handle);
configASSERT(status == pdPASS);

eventQueue = xQueueCreate(2, sizeof(QUEUE_DATA));
configASSERT(eventQueue != NULL);

vTaskStartScheduler();
</code></pre>
										</div>
									</section>
									
								<!-- Code -->
									<section>
										<header>
											<h3>receiver.c</h3>
											<p>The NRF24L01 module is first initialized for receiving. The receiver continuously checks the 
												FIFO for a payload from the transmitter. The data is saved to their respective variables and 
												then packaged together as a "Joystick" event which is sent to the event queue.</p>
										</header>
										
										<div class="content">
											<pre><code>// Initialize the nRF24L01 to its default state
init_receiver();

while (1) {
	// Constantly poll the status of the RX FIFO and get a payload if FIFO is not empty
	if (nRF24_GetStatus_RXFIFO() != nRF24_STATUS_RXFIFO_EMPTY) {
		// Get a payload from the transceiver
		pipe = nRF24_ReadPayload(nRF24_payload, &payload_length);

		VRy |= nRF24_payload[0] << 8;
		VRy |= nRF24_payload[1];
		VRx |= nRF24_payload[2] << 8;
		VRx |= nRF24_payload[3];

		throttle_limit |= nRF24_payload[4] << 8;
		throttle_limit |= nRF24_payload[5];

		enable_ultrasonic = nRF24_payload[6];

		toggleHeadlights = nRF24_payload[7];

		q_data.eventType = JOYSTICK;
		q_data.data[0] = VRy;
		q_data.data[1] = VRx;
		q_data.data[2] = throttle_limit;
		q_data.data[3] = enable_ultrasonic;
		q_data.data[4] = toggleHeadlights;

		if(!enable_ultrasonic)
			vTaskSuspend(ultrasonic_task_handle);
		else
			vTaskResume(ultrasonic_task_handle);
			
		xQueueSend(eventQueue, &q_data, portMAX_DELAY);
	}
}
</code></pre>
										</div>
									</section>
									
								<!-- Code -->
									<section>
										<header>
											<h3>ultrasonic.c</h3>
											<p>The ultrasonic task sends out a high Trig pulse and starts the htim2 timer. It waits until
												Echo goes low and then calculates the distance. Now instead of using this distance reading in
												the obstacle detecting code, it is used in store_reading. The store_reading() algorithm takes 5
												distance readings of the ultrasonic sensor and computes the median of those values. This is
												done to prevent false readings and increase reliability. The algorithm used to sort these
												values is a bitonic sort with 5 inputs. The median value is packaged as an "Ultrasonic" event
												which is sent to the event queue.</p>
										</header>
										
										<div class="content">
											<pre><code>void ultrasonic_task(void *param)
{
	while(1){
		HAL_GPIO_WritePin(Trig_GPIO_Port, Trig_Pin, GPIO_PIN_RESET);
		delay_us(2);

		HAL_GPIO_WritePin(Trig_GPIO_Port, Trig_Pin, GPIO_PIN_SET);
		delay_us(10);
		HAL_GPIO_WritePin(Trig_GPIO_Port, Trig_Pin, GPIO_PIN_RESET);

		while(!HAL_GPIO_ReadPin(Echo_GPIO_Port, Echo_Pin))
		{
			//wait until echo goes high
			x1 = __HAL_TIM_GET_COUNTER(&htim2);
		}

		while(HAL_GPIO_ReadPin(Echo_GPIO_Port, Echo_Pin))
		{
			//wait until echo goes low
			x2 = __HAL_TIM_GET_COUNTER(&htim2);
		}

		//calculate distance
		dist = (x2-x1) * 0.034/2;

		store_reading(dist);
	}
}

void delay_us(uint16_t delay)
{
	__HAL_TIM_SET_COUNTER(&htim2,0);
	while(__HAL_TIM_GET_COUNTER(&htim2) < delay);
}

#define CMP_SWAP(i, j) if (dist_readings[i] > dist_readings[j]) \
	{ int tmp = dist_readings[i]; dist_readings[i] = dist_readings[j]; dist_readings[j] = tmp; }
#define MAX_READINGS	5

void store_reading(uint16_t dist)
{
	dist_readings[i] = dist;
	i++;

	//array full. Only works for 5 entries
	if(i == MAX_READINGS)
	{
		CMP_SWAP(0, 3); CMP_SWAP(1, 4); CMP_SWAP(0, 2); CMP_SWAP(1, 3);
		CMP_SWAP(0, 1); CMP_SWAP(2, 4); CMP_SWAP(1, 2); CMP_SWAP(3, 4);
		CMP_SWAP(2, 3);

		median_dist = dist_readings[MAX_READINGS/2];
		i=0;
		memset(dist_readings, 0, sizeof(dist_readings));

		q_data.eventType = ULTRASONIC;
		q_data.data[0] = median_dist;

		if(firstReading)
		{
			t1 = HAL_GetTick();
			firstDist = dist;
			firstReading = 0;
		}
		else
		{
			t2 = HAL_GetTick();
			temp = (int)(t2 - t1) / (double)1000;
			speed = (firstDist - dist) / temp;
			speedArray[idx] = speed;
			idx = (idx+1) % 100;
			firstReading = 1;
		}

		//send to front because its important. Dont block if queue is full
		xQueueSendToFront(eventQueue, &q_data, ( TickType_t ) 0);

		vTaskDelay(150);
	}
}
</code></pre>
										</div>
									</section>
									
								<!-- Code -->
									<section>
										<header>
											<h3>motor.c</h3>
											<p>The motor task can recieve "Joystick" or "Ultrasonic" events and processes each one differently
												In a "Joystick" event, the values from the joystick and potentiometer (throttle control) are 
												used together in throttleToPwm() to find the final pwm value that should be used to move left, 
												right, forward, or
												backward. When moving forward and backward, calcDelay() is used to prevent quick changes in
												those directions which can cause damage to the motors and motor driver. In an "Ultrasonic"
												event, the median distance value is used to choose whether to stop or continue forward
												(if enable_ultrasonic is set from the toggle switch of the transmitter). calcStopDistance()
												is used to calculate the stopping distance from an object based on how fast the car is moving. 
												In other words, if the car is moving fast, the car stops much sooner than if it was moving slow. 
												This algorithm is far from efficient as I used trial and error on different speeds. A better 
												approach is to use an accelerometer and gyroscope sensor.</p>
										</header>
										
										<div class="content">
											<pre><code>#define DEFAULT_X		2000
#define DEFAULT_Y		2000
#define THRESHOLD_AXIS		30
#define MAX_PWM			(htim1.Init.Period)
#define MIN_PWM_PERC		.1
#define MAX_THROTTLE		4038

typedef enum {
	BRAKE = 0,
	FORWARD = 1,
	BACKWARD = 2
} Direction;

void motor_task(void *param)
{
	while(1)
	{
		status = xQueueReceive(eventQueue, &q_data, portMAX_DELAY);
		if(status == pdTRUE)
		{
			if(q_data.eventType == JOYSTICK)
			{
				posY = q_data.data[0];
				posX = q_data.data[1];
				throttle_limit = q_data.data[2];
				enable_ultrasonic = q_data.data[3];
				toggleHeadlights = q_data.data[4];

				if(toggleHeadlights)
					HAL_GPIO_TogglePin(HeadLights_GPIO_Port, HeadLights_Pin);

				stop = enable_ultrasonic ? stop : 0;

				newMaxPwm = ((double)throttle_limit / MAX_THROTTLE) * MAX_PWM;
				minPwm = newMaxPwm * MIN_PWM_PERC;


				HAL_GPIO_WritePin(PWMB_GPIO_Port, PWMB_Pin, GPIO_PIN_SET);
				//Turn Right
				if(posX >= DEFAULT_X+THRESHOLD_AXIS)
				{
					HAL_GPIO_WritePin(FrontMotor_IN1_GPIO_Port, FrontMotor_IN1_Pin, GPIO_PIN_SET);
					HAL_GPIO_WritePin(FrontMotor_IN2_GPIO_Port, FrontMotor_IN2_Pin, GPIO_PIN_RESET);
				}
				//Turn Left
				else if(posX <= DEFAULT_X-THRESHOLD_AXIS)
				{
					HAL_GPIO_WritePin(FrontMotor_IN1_GPIO_Port, FrontMotor_IN1_Pin, GPIO_PIN_RESET);
					HAL_GPIO_WritePin(FrontMotor_IN2_GPIO_Port, FrontMotor_IN2_Pin, GPIO_PIN_SET);
				}
				//No turn
				else if(posX < DEFAULT_X+THRESHOLD_AXIS || posX > DEFAULT_X-THRESHOLD_AXIS)
				{
					HAL_GPIO_WritePin(FrontMotor_IN1_GPIO_Port, FrontMotor_IN1_Pin, GPIO_PIN_SET);
					HAL_GPIO_WritePin(FrontMotor_IN2_GPIO_Port, FrontMotor_IN2_Pin, GPIO_PIN_SET);
				}

				//Forward
				if((posY <= DEFAULT_Y-THRESHOLD_AXIS) && !stop)
				{
					dirDelay = HAL_GetTick() - lastDirDelay;
					maxDirDelay = calcDelay(pwmY);
					if(state == BACKWARD && (dirDelay < maxDirDelay))
					{
						state = BRAKE;
						brake();
						vTaskDelay(maxDirDelay - dirDelay);
					}
					else
					{
						state = FORWARD;
						pwmY = throttleToPwm(posY);
						throttle(pwmY);
					}
				}
				//Backward
				else if(posY >= DEFAULT_Y+THRESHOLD_AXIS)
				{
					dirDelay = HAL_GetTick() - lastDirDelay;
					maxDirDelay = calcDelay(pwmY);
					if(state == FORWARD && (dirDelay < maxDirDelay))
					{
						state = BRAKE;
						brake();
						vTaskDelay(maxDirDelay - dirDelay);
					}
					else
					{
						state = BACKWARD;
						pwmY = throttleToPwm(posY);
						throttle(pwmY);
					}
				}
				//Brake
				else if(posY < DEFAULT_Y+THRESHOLD_AXIS || posY > DEFAULT_Y-THRESHOLD_AXIS)
				{
					brake();
				}
			}
			else if(q_data.eventType == ULTRASONIC && enable_ultrasonic)
			{
				stopDistance = calcStopDistance(pwmY);
				median_dist = q_data.data[0];
				if(median_dist > stopDistance && !stop)
				{
					stop = 0;
				}
				else if((median_dist <= stopDistance))
				{
					stop = 1;
				}
				//avoid flickering between red and green
				else if(median_dist > stopDistance+3 && stop)
				{
					stop = 0;
				}
			}
		}
	}
}

uint32_t throttleToPwm(uint32_t adcVal)
{
	int a = 4035 - (DEFAULT_Y+THRESHOLD_AXIS);	//a=2000
	double b = abs(adcVal - (DEFAULT_Y+THRESHOLD_AXIS));
	double c = (b / a) * (1-MIN_PWM_PERC);
	uint32_t newPwm = minPwm + (newMaxPwm * c);

	return newPwm;
}

uint32_t calcDelay(uint32_t pwmY)
{
	uint32_t delay = 100;
	if(pwmY > MAX_PWM/2)
		delay += ((pwmY/10)*4);

	return delay;
}

uint32_t calcStopDistance(uint32_t pwmY)
{
	uint32_t distance = 10;
	distance += pwmY/8;

	return distance;
}

void brake(void)
{
	HAL_GPIO_WritePin(BackMotor_IN1_GPIO_Port, BackMotor_IN1_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(BackMotor_IN2_GPIO_Port, BackMotor_IN2_Pin, GPIO_PIN_RESET);
	__HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, 0);
}

void throttle(uint32_t pwmY)
{
	if(state == FORWARD)
	{
		HAL_GPIO_WritePin(BackMotor_IN1_GPIO_Port, BackMotor_IN1_Pin, GPIO_PIN_RESET);
		HAL_GPIO_WritePin(BackMotor_IN2_GPIO_Port, BackMotor_IN2_Pin, GPIO_PIN_SET);
	}
	else if(state == BACKWARD)
	{
		HAL_GPIO_WritePin(BackMotor_IN1_GPIO_Port, BackMotor_IN1_Pin, GPIO_PIN_SET);
		HAL_GPIO_WritePin(BackMotor_IN2_GPIO_Port, BackMotor_IN2_Pin, GPIO_PIN_RESET);
	}

	__HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, pwmY);
	lastDirDelay = HAL_GetTick();
}
</code></pre>
										</div>
									</section>
									
							</div>
						</div>
					</section>
									
				<!-- Additional Elements -->
					<section class="wrapper style1 align-center">
						<div class="inner">
							<h2>Additional Items</h2>
							<p>Details.</p>
							<div class="index align-left">
						
								<!-- Table -->
									<section>
										<header>
											<h3>Motor Driver Control Signal Logic</h3>
										</header>
										<div class="content">
											<div class="table-wrapper">
												<table class="alt">
													<thead>
														<tr>
															<th>IN1</th>
															<th>IN2</th>
															<th>ENA</th>
															<th>OUT</th>
														</tr>
													</thead>
													<tbody>
														<tr>
															<td>0</td>
															<td>0</td>
															<td>X</td>
															<td>Brake</td>
														</tr>
														<tr>
															<td>1</td>
															<td>1</td>
															<td>X</td>
															<td>Floating</td>
														</tr>
														<tr>
															<td>1</td>
															<td>0</td>
															<td>PWM</td>
															<td>Forward to speed</td>
														</tr>
														<tr>
															<td>0</td>
															<td>1</td>
															<td>PWM</td>
															<td>Backward to speed</td>
														</tr>
														<tr>
															<td>1</td>
															<td>0</td>
															<td>1</td>
															<td>Full speed forward</td>
														</tr>
														<tr>
															<td>0</td>
															<td>1</td>
															<td>1</td>
															<td>Full speed backward</td>
														</tr>
													</tbody>
												</table>
											</div>

										</div>
									</section>
									
								<!-- Table -->
									<section>
										<header>
											<h3>Bitonic Sort with 5 Inputs</h3>
										</header>
										<div class="image">
											<img src="images/gallery/design/bitonic_sort.png" alt="" />
										</div>
									</section>
								
							</div>
						</div>
					</section>
					
				<!-- Challenges -->
					<section class="wrapper style1 align-center">
						<div class="inner">
							<h2>Challenges</h2>
							<p>Details.</p>
							<div class="index align-left">
						
								<!-- RC Car Selection -->
									<section>
										<header>
											<h3>RC Car Selection</h3>
										</header>
										<div class="content">
											<p>Hello</p>

										</div>
									</section>
									
								<!-- Motor Driver Selection -->
									<section>
										<header>
											<h3>Motor Driver Selection</h3>
										</header>
										<div class="content">
											<p>Hello</p>

										</div>
									</section>
								
							</div>
						</div>
					</section>
					
					
				<!-- Footer -->
					<footer class="wrapper style1 align-center">
						<div class="inner">
							<p>&copy; Muhmin Abdeljaber/STM32 RC Car 2023 | All rights reserved.</p>
						</div>
					</footer>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>